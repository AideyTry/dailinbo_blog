{"remainingRequest":"E:\\practiceProject\\blog\\my-blog\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!E:\\practiceProject\\blog\\my-blog\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js??ref--1-2!E:\\practiceProject\\blog\\my-blog\\docs\\vue\\base.md?vue&type=template&id=2d45f46d&","dependencies":[{"path":"E:\\practiceProject\\blog\\my-blog\\docs\\vue\\base.md","mtime":1544626535381},{"path":"E:\\practiceProject\\blog\\my-blog\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\practiceProject\\blog\\my-blog\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"E:\\practiceProject\\blog\\my-blog\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\practiceProject\\blog\\my-blog\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"E:\\practiceProject\\blog\\my-blog\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js","mtime":1533872387000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"一、vue基础知识\"><a class=\"header-anchor\" href=\"#一、vue基础知识\" aria-hidden=\"true\">#</a> 一、vue基础知识</h1>\n<pre><code>1、模板语法\n    ```\n    Mustache语法：{{12}}\n    Html赋值：v-html\n    绑定属性: v-bind:id=&quot;&quot;  :id\n    使用表达式:  {{ok?'yes':'no'}}\n    文本赋值: v-text=&quot;&quot;\n    指令v-if\n    过滤器:{{message | capitalize}} 和 v-bind:id=&quot;rawId | formatId&quot;\n    ```\n\n  2、Class和Style绑定\n\n    ```\n      对象语法: v-bind:class=&quot;{ active: isActive, 'text-danger': hasError }&quot;&gt;\n\n      数组语法:&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;\n      data: {\n        activeClass: 'active',\n        errorClass: 'text-danger'\n      }\n      &lt;div v-bind:class=&quot;[isActive ? activeClass : '', errorClass]&quot;&gt;&lt;/div&gt;\n\n      style绑定对象语法：&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;&gt;&lt;/div&gt;\n      data: {\n        activeColor: 'red',\n        fontSize: 30\n      }\n    ```\n\n  3、条件渲染\n    ```\n      v-if\n      v-else\n      v-else-if\n      v-show\n      v-cloak\n      [v-cloak] {\n      display: none;\n      }\n      &lt;div v-cloak&gt;\n        {{ message }}\n      &lt;/div&gt;\n    ```\n\n  4、vue事件处理器\n    ```\n      v-on:click=&quot;greet&quot;或@click=&quot;greet&quot;\n\n      事件修饰符：\n      v-on:click.stop 阻止冒泡\n      v-on:click.stop.prevent 阻止默认事件（阻止按钮的默认事件，例如a标签让点击的打开新窗口或新页面失效）\n      v-on:click.self 给对象本身绑定事件，如果元素中有子元素，点击子元素是没有作用的。\n      v-on:click.once 只给事件绑定只生效一次\n\n      v-on:keyup.enter\n      enter/tab/delete(捕获删除和退格键)/esc/space/up/down/left/right\n\n    ```\n\n  5、Vue组件\n    ```\n      全局组件和局部组件\n      SPA一般是局部组件，多页面会有全局组件。\n\n      父子组件通讯-数据传递\n      (组件单向流，只允许父组件传递给子组件数据不允许子组件修改父组件变量，因为组件之间嵌套很复杂，为了防止紊乱。但可以通过$emit变相更改)\n\n      Slot\n    ```\n</code></pre>\n<h1 id=\"二、vue-router\"><a class=\"header-anchor\" href=\"#二、vue-router\" aria-hidden=\"true\">#</a> 二、vue-router</h1>\n<pre><code>  1、什么是前端路由?\n      路由是根据不同的url地址展示不同的内容或页面\n      前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据url的不同返回不同的页面实现的（后端直出渲染）。其实前端路由前端页面只有首页是存在的，其他的是虚拟出来的。SPA需要前端路由。\n      vue-router实际上是对history的封装。\n  2、前端路由由什么优点和缺点？\n      优点:\n          用户体验好，不需要每次都从服务器全部获取，快速展现给用户（只需首页获取）。\n      缺点：\n          不利于SEO（因为除了首页其他页面路径虚拟出来的）\n          使用浏览器的前进，后退键的时候会重新发送请求，没有合理的利用缓存；\n          单页面无法记住之前滚动的位置，无法在前进、后退的时候记住滚动的位置。\n\n  3、vue-router用来构建SPA\n        vue-router本质上是对history的封装。\n        &lt;router-link&gt;&lt;/router-link&gt;或者this.$router.push({path:''})跳转\n        &lt;router-view&gt;&lt;/router-view&gt;组件渲染  一个载体，专门承担组件选择，承载一级路由\n\n\n  4.vue-router使用\n\n          动态路由匹配\n\n          模式                 \t\t  |匹配路径\t\t\t\t\t\t\t\t\t\t\t|$route.params\n\n          --|:--|--:\n\n          /user/:username | /user/evan | { username: 'evan' } \n          /user/:username/post/:post_id |/user/evan/post/123  |\t{ username: 'evan', post_id: 123 }\n\n        嵌套路由\n\n        编程式路由\n          $router.push({path:'name?a=123'})或者$router.push({path:'name',query:{a:123}})\n          $router.go(1)\n        命名路由和命名视图\n\n        什么是命名路由和命名视图？\n        给路由定义不同的名字，根据名字进行匹配。\n        给不同的router-view定义名字，通过名字进行对应组件的渲染。\n          例如\n          ```\n            &lt;router-view&gt;&lt;/router-view&gt;\n            &lt;router-view name=&quot;title&quot;&gt;&lt;/router-view&gt;\n            &lt;router-view name=&quot;img&quot;&gt;&lt;/router-view&gt;\n            routes:[\n              {\n                path:'/',\n                name:'GoodsList',\n                components:{\n                  default:GoodaList,\n                  title:Title,\n                  img:Image\n                }\n              }\n            ]\n          ```\naxios\n  https://www.kancloud.cn/yunye/axios/234845\n         ```\n          axios直接暴露到全局\n          成功.then() 失败.catch()。链式操作。\n          axios.get()\n          axios.post()\n          http配置。get请求通过params:{}传递参数。post请求通过data:{}传递参数\n          axios.all() 可同时请求多个接口\n\n          全局拦截：\n          request拦截\n          axios.interceptors.request.use()\n          请求之前可以做一些Loading处理或其他业务处理。\n          response拦截\n          axios.interceptors.response.use()\n         ```\n箭头函数作用域和外面作用域是一样的，没有产生新的作用域。\n</code></pre>\n<h1 id=\"三-es6\"><a class=\"header-anchor\" href=\"#三-es6\" aria-hidden=\"true\">#</a> 三 ES6</h1>\n<pre><code>  ECMAScript 6\n\n  1、函数的Rest参数和扩展</code></pre>\n</div>\n",null]}